#
#  Copyright (c) 2020 NetEase Inc.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#

#
#MDS side configuration information
#
#Address information of mds
mds.listen.addr=127.0.0.1:9160

#Register switch with mds during initialization phase, default to on
mds.registerToMDS=true

#Time out for communication with mds
mds.rpcTimeoutMS=1000

#The maximum timeout time for communication with MDS, and the timeout for exponential backoff cannot exceed this value
mds.maxRPCTimeoutMS=2000

#Switch if the number of consecutive retries on the current mds exceeds this limit
mds.maxFailedTimesBeforeChangeMDS=5

#How many renewals are there within a lease period with MDS
mds.refreshTimesPerLease=4

#The mds RPC interface requires a period of sleep before each retry
mds.rpcRetryIntervalUS=100000

#
#################Metacache Configuration Information################
#

#Obtain the rpc timeout of the leader
metacache.getLeaderTimeOutMS=1000

#Obtain the backup request timeout for the leader
metacache.getLeaderBackupRequestMS=100

#Retrieve the number of retries for the leader
metacache.getLeaderRetry=3

#The getleader interface needs to sleep for a period of time before each retry
metacache.rpcRetryIntervalUS=100000

#
###############Configuration information of the scheduling layer#############
#

#Scheduling layer queue size, with one queue for each file
#The depth of the scheduling queue can affect the overall throughput of the client, as it stores asynchronous IO tasks..
schedule.queueCapacity=4096

#Number of execution threads in the queue
#What the executing thread needs to do is to retrieve the IO, then send it to the network and return to retrieve the next network task. A task starts from
#The RPC request is approximately (20us-100us) from the time the queue is retrieved to the time it is sent, and 20us is the normal time when it is not necessary to obtain a leader
#If a leader needs to be obtained during sending, the time will be around 100us, and the throughput of one thread will be between 10w-50w
#The performance has met the requirements
schedule.threadpoolSize=2

#To isolate the task queue introduced by the QEMU side thread, as there is only one IO thread on the QEMU side
#When the QEMU side calls the AIO interface, it directly pushes the call to the task queue and returns,
#This way, libcurve does not occupy QEMU's threads and does not block its asynchronous calls
isolation.taskQueueCapacity=500000

#Task queue thread pool size, default value is 1 thread
isolation.taskThreadPoolSize=1


#
################Configuration related to communication with chunkserver#############
#
#Retrying sleep between OPs with failed read/write interfaces
chunkserver.opRetryIntervalUS=50000

#Number of failed OP retries
chunkserver.opMaxRetry=3

#RPC timeout for communication with chunkserver
chunkserver.rpcTimeoutMS=1000

#Enable reading based on applicatindindex for performance optimization
chunkserver.enableAppliedIndexRead=1

# Maximum sharding KB for issuing IO
global.fileIOSplitMaxSizeKB=4

# Libcurve allows for the maximum number of unreturned rpcs in the underlying rpc scheduling, with each file's inflight RPC being independent
global.fileMaxInFlightRPCNum=2048

# Maximum sleep time between retry requests
# Because when the network is congested or the chunkserver is overloaded, it is necessary to increase sleep time
# The maximum time for this is maxRetrySleepIntervalUs
chunkserver.maxRetrySleepIntervalUS=8000000

# The maximum timeout rpc time for retry requests, which follows an exponential backoff strategy
# Because timeout occurs when the network is congested, it is necessary to increase the RPC timeout time
# The maximum time for this is maxTimeoutMS
chunkserver.maxRPCTimeoutMS=8000

# Maximum number of consecutive timeouts for the same chunkserver
# If this value is exceeded, a health check will be conducted, and if the health check fails, it will be marked as unstable
chunkserver.maxStableTimeoutTimes=64
# The timeout of health check requests after consecutive RPC timeouts on chunkserver
chunkserver.checkHealthTimeoutMs=100
# After the number of unstable chunkservers on the same server exceeds this value
# All chunkservers will be marked as unstable
chunkserver.serverStableThreshold=3

#When an RPC retry exceeds maxRetryTimesBeforeConsiderSuspend
#Record as suspended IO, metric will alarm
chunkserver.maxRetryTimesBeforeConsiderSuspend=20

chunkserver.opRetryIntervalUS=100000
metacache.getLeaderBackupRequestMS=100
#
#################Log related configuration###############
#
#Log level INFO=0/WARNING=1/ERROR=2/FATAL=3
global.logLevel=0
#Set the path of the log
global.logPath=./runlog/
#In the case of unit testing
# logpath=./runlog/

#
###############Metric configuration information#############
#
global.metricDummyServerStartPort=9000

#
#Session map file, storing the mapping from filename to path of the opened file
#
global.sessionMapPath=./session_map.json
