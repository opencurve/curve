#
#  Copyright (c) 2020 NetEase Inc.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#

#
# MDS side configuration information
#
# Address information of mds
mds.listen.addr=127.0.0.1:9160

# Register switch with mds during initialization phase, default to on
mds.registerToMDS=true

# Time out for communication with mds
mds.rpcTimeoutMS=1000

# The maximum timeout time for communication with MDS, and the timeout for exponential backoff cannot exceed this value
mds.maxRPCTimeoutMS=2000

# Switch if the number of consecutive retries on the current mds exceeds this limit
mds.maxFailedTimesBeforeChangeMDS=5

# How many renewals are there within a lease period with MDS
mds.refreshTimesPerLease=4

# The mds RPC interface requires a period of sleep before each retry
mds.rpcRetryIntervalUS=100000

#
################# Metacache Configuration Information ################
#

# Obtain the rpc timeout of the leader
metacache.getLeaderTimeOutMS=1000

# Obtain the backup request timeout for the leader
metacache.getLeaderBackupRequestMS=100

# Retrieve the number of retries for the leader
metacache.getLeaderRetry=3

# The getleader interface needs to sleep for a period of time before each retry
metacache.rpcRetryIntervalUS=100000

#
###############Configuration information of the scheduling layer#############
#

# Scheduling layer queue size, with one queue for each file
# The depth of the scheduling queue can affect the overall throughput of the client, as it stores asynchronous IO tasks..
schedule.queueCapacity=4096

# Number of Execution Threads for the Queue
# The task of execution threads is to retrieve IO and then send it over the network before moving on to the next network task. 
# The time it takes for a task to be retrieved from the queue and the RPC request to be sent typically ranges from 20 microseconds (20us) to 100 microseconds (100us). 
# The lower end of this range, 20us, is under normal conditions when leader acquisition is not required during transmission. If leader acquisition is necessary during transmission, the time may extend to around 100us. 
# The throughput of a single thread ranges from 100,000 (10w) to 500,000 (50w) tasks per second. This performance level meets the requirements.
schedule.threadpoolSize=2

# To isolate the task queue introduced by the QEMU side thread, as there is only one IO thread on the QEMU side
# When the QEMU side calls the AIO interface, it directly pushes the call to the task queue and returns,
# This way, libcurve does not occupy QEMU's threads and does not block its asynchronous calls
isolation.taskQueueCapacity=500000

# Task queue thread pool size, default value is 1 thread
isolation.taskThreadPoolSize=1


#
################ Configuration related to communication with chunkserver #############
#
# Retrying sleep between OPs with failed read/write interfaces
chunkserver.opRetryIntervalUS=50000

# Number of failed OP retries
chunkserver.opMaxRetry=3

# RPC timeout for communication with chunkserver
chunkserver.rpcTimeoutMS=1000

# Enable reading based on appliedindex for performance optimization
chunkserver.enableAppliedIndexRead=1

# Maximum sharding KB for issuing IO
global.fileIOSplitMaxSizeKB=4

# libcurve allows for the maximum number of unreturned rpcs in the underlying rpc scheduling, with each file's inflight RPC being independent
global.fileMaxInFlightRPCNum=2048

# Maximum sleep time between retry requests
# Because when the network is congested or the chunkserver is overloaded, it is necessary to increase sleep time
# The maximum time for this is maxRetrySleepIntervalUs
chunkserver.maxRetrySleepIntervalUS=8000000

# The maximum timeout rpc time for retry requests, which follows an exponential backoff strategy
# Because timeout occurs when the network is congested, it is necessary to increase the RPC timeout time
# The maximum time for this is maxTimeoutMS
chunkserver.maxRPCTimeoutMS=8000

# Maximum number of consecutive timeouts for the same chunkserver
# If this value is exceeded, a health check will be conducted, and if the health check fails, it will be marked as unstable
chunkserver.maxStableTimeoutTimes=64
# The timeout of health check requests after consecutive RPC timeouts on chunkserver
chunkserver.checkHealthTimeoutMs=100
# After the number of unstable chunkservers on the same server exceeds this value
# All chunkservers will be marked as unstable
chunkserver.serverStableThreshold=3

# When an RPC retry exceeds maxRetryTimesBeforeConsiderSuspend
# Record as suspended IO, metric will alarm
chunkserver.maxRetryTimesBeforeConsiderSuspend=20

chunkserver.opRetryIntervalUS=100000
metacache.getLeaderBackupRequestMS=100
#
################# Log related configuration ###############
#
# Log level INFO=0/WARNING=1/ERROR=2/FATAL=3
global.logLevel=0
# Set the path of the log
global.logPath=./runlog/
# In the case of unit testing
# logpath=./runlog/

#
############### metric configuration information #############
#
global.metricDummyServerStartPort=9000

#
# session map file, storing the mapping from filename to path of the opened file
#
global.sessionMapPath=./session_map.json
