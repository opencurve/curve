/*
 *  Copyright (c) 2020 NetEase Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

/*
 * Project: curve
 * File Created: Thursday, 6th September 2018 10:49:30 am
 * Author: yangyaokai
 */
#ifndef SRC_CHUNKSERVER_DATASTORE_CHUNKSERVER_CHUNKFILE_V2_H_
#define SRC_CHUNKSERVER_DATASTORE_CHUNKSERVER_CHUNKFILE_V2_H_

#include <glog/logging.h>
#include <butil/iobuf.h>
#include <string>
#include <vector>
#include <set>
#include <atomic>
#include <functional>
#include <memory>
#include <condition_variable>
#include <map>

#include "include/curve_compiler_specific.h"
#include "include/chunkserver/chunkserver_common.h"
#include "src/common/concurrent/rw_lock.h"
#include "src/common/crc32.h"
#include "src/common/timeutility.h"
#include "src/fs/local_filesystem.h"
#include "src/chunkserver/datastore/filename_operator.h"
#include "src/chunkserver/datastore/chunkserver_snapshot.h"
#include "src/chunkserver/datastore/define.h"
#include "src/chunkserver/datastore/file_pool.h"
#include "src/common/fast_align.h"
#include "src/chunkserver/datastore/chunkserver_chunkfile.h"

namespace curve {
namespace chunkserver {

using curve::fs::LocalFileSystem;
using curve::common::RWLock;
using curve::common::WriteLockGuard;
using curve::common::ReadLockGuard;
using curve::common::BitRange;
using curve::common::TimeUtility;

class FilePool;
class CSSnapshot;
struct DataStoreMetric;
class CSDataStore;

class CSChunkFile_V2 : public CSChunkFile {
 public:
    friend class CSSnapshots;
 public:
    CSChunkFile_V2(std::shared_ptr<LocalFileSystem> lfs,
                std::shared_ptr<FilePool> chunkFilePool,
                const ChunkOptions& options);
    virtual ~CSChunkFile_V2() override;

    /**
     * When a Chunk file is found when Datastore is initialized, this
     * interface will be called to initialize the Chunk file
     * Normally, there is no concurrency, mutually exclusive with other
     * operations, add write lock
     * @createFile: true means to create a new file, false not to create a
     *              file
     * @return returns the error code
     */
    virtual CSErrorCode Open(bool createFile) override;

    /**
     * Called when a snapshot file is found during Datastore initialization
     * Load the metapage of the snapshot file into the memory inside the
     * function.
     * Under normal circumstances, there is no concurrency, mutually exclusive
     * with other operations, add write lock.
     * @param sn: the sequence number of the snapshot file to be loaded
     * @return: return error code
     */
    virtual CSErrorCode LoadSnapshot(SequenceNum sn) override;
     /**
     * Called when a snapshot file is deleted
     * and merged to a non-existent snapshot file.
     * Write lock should NOT be added
     * @param sn: the sequence number of the snapshot file to be loaded
     * @return: return error code
     */
    virtual CSErrorCode loadSnapshot(SequenceNum sn) override;
    /**
     * Write chunk files
     * The Write interface is called when raft apply, and there is no multiple
     * concurrency between Writes.
     * But it may be concurrent with other operations such as Read and Delete,
     * add write lock
     * @param sn: The file sequence number of the current write request
     * @param buf: data requested to be written
     * @param offset: The offset position of the request to write
     * @param length: The length of the data requested to be written
     * @param cost: The actual number of IOs generated by this request,
     * used for QOS control
     * @param ctx: snapshot context
     * @return: return error code
     */
    virtual CSErrorCode Write(SequenceNum sn,
                      const butil::IOBuf& buf,
                      off_t offset,
                      size_t length,
                      uint32_t* cost,
                      std::shared_ptr<SnapContext> ctx) override;

    virtual CSErrorCode cloneWrite(SequenceNum sn,
                        const butil::IOBuf& buf,
                        off_t offset,
                        size_t length,
                        uint32_t* cost,
                        const std::unique_ptr<CloneContext>& cloneCtx,
                        CSDataStore* datastore,
                        std::shared_ptr<SnapContext> ctx = nullptr) override;
    /**
     * Flatten Clone Chunk
     * @param sn: The sn version of the current chunk snapshot
     * @param offset: The offset position of the request to begin flatten
     * @param length: The length of the data requested to be flatten
     * @param cloneCtx: clone context
     * @param datastore: datastore
     * @return: return error code
     */
    virtual CSErrorCode flattenWrite(SequenceNum sn,
                        off_t offset, size_t length,
                        const std::unique_ptr<CloneContext>& cloneCtx,
                        CSDataStore* datastore) override;

    /**
     * Write the copied data into Chunk
     * Only write areas that have not been written, and will not overwrite
     * areas that have been written
     * There may be concurrency, add write lock
     * @param buf: request Paste data
     * @param offset: the starting offset of the data requesting Paste
     * @param length: the length of the data requested for Paste
     * @return: return error code
     */
    virtual CSErrorCode Paste(const char * buf, off_t offset, size_t length) override {
        // The Paste interface is not supported in the current version
        // LOG the error and return
        LOG(ERROR) << "Paste interface is not supported in the current version";
        return CSErrorCode::IncompatibleError;
    }
    /**
     * Read the chunk of the specified Sequence
     * There may be concurrency, add read lock
     * @param sn: SequenceNum of the specified chunk
     * @param buf: Snapshot data read
     * @param offset: the starting offset of the snapshot data requested to be
     *                read
     * @param length: The length of the snapshot data requested to be read
     * @return: return error code
     */
    virtual CSErrorCode ReadSpecifiedChunk(SequenceNum sn,
                                   char * buf,
                                   off_t offset,
                                   size_t length) override;
    /**
     * Delete chunk files.
     * Normally there is no concurrency, mutually exclusive with other
     * operations, add write lock.
     * @param: The file sequence number when calling the DeleteChunk interface
     * @return: return error code
     */
    virtual CSErrorCode Delete(SequenceNum sn) override;
    /**
     * Delete snapshots generated during this dump or left over from history.
     * If no snapshot is generated during the dump, modify the correctedSn of
     *  the chunk.
     * Normally there is no concurrency, mutually exclusive with other
     * operations, add write lock.
     * @param correctedSn: The sequence number of the chunk that needs to be
     * corrected, essentially the sequence number of the file after the
     * snapshot.
     * Corrected to this parameter value when the chunk does not have a
     *  snapshot.
     * @return: return error code
     */
    virtual CSErrorCode DeleteSnapshot(SequenceNum snapSn,
        std::shared_ptr<SnapContext> ctx = nullptr) override;
    /**
     * Get chunk info
     * @param[out]: the chunk info getted
     */
    virtual void GetInfo(CSChunkInfo* info) override;

    uint64_t getCloneNumber() override {
        return metaPage_.cloneNo;
    }

    virtual ChunkID getVirtualId() override {
        return metaPage_.virtualId;
    }

    virtual uint64_t getFileID() override {
        return metaPage_.fileId;
    }

    virtual bool DivideObjInfoByIndex(SequenceNum sn,
                        std::vector<BitRange>& range,  // NOLINT
                        std::vector<BitRange>& notInRanges,  // NOLINT
                        std::vector<ObjectInfo>& objInfos) override;  // NOLINT

    virtual bool DivideObjInfoByIndexLockless(SequenceNum sn,
                        std::vector<BitRange>& range,  // NOLINT
                        std::vector<BitRange>& notInRanges,  // NOLINT
                        std::vector<ObjectInfo>& objInfos) override;  // NOLINT

    virtual bool DivideSnapshotObjInfoByIndex(SequenceNum sn,
                        std::vector<BitRange>& range,  // NOLINT
                        std::vector<BitRange>& notInRanges,  // NOLINT
                        std::vector<ObjectInfo>& objInfos) override;  // NOLINT

    virtual CSErrorCode ReadSpecifiedSnap(SequenceNum sn,
                        CSSnapshot* snap,
                        char* buff,
                        off_t offset,
                        size_t length) override;

    int FindExtraReadFromParent(std::vector<File_ObjectInfoPtr>& objIns,  // NOLINT
                                off_t offset,
                                size_t length);

    void MergeObjectForRead(std::map<int32_t, Offset_InfoPtr>& objmap,  // NOLINT
                            std::vector<File_ObjectInfoPtr>& objIns);  // NOLINT

    // Write the data to the chunk file and 
    // copy original data to the snapshot file
    // @param sn: the sequence number of the snapshot file to be loaded
    // @param buf: the data requested to be written
    // @param offset: the starting offset of the data requested to be written
    // @param length: the length of the data requested to be written
    // @param cost: The actual number of IOs generated by this request,
    // used for QOS control
    // @param ctx: snapshot context
    CSErrorCode writeSnapData(SequenceNum sn,
                            const butil::IOBuf& buf,
                            off_t offset,
                            size_t length,
                            uint32_t* cost,
                            std::shared_ptr<SnapContext> ctx = nullptr);
    
    // Read frome parent and flatten the current chunk
    // @param sn: the sequence number of the snapshot file to be loaded
    // @param buf: the data requested to be written
    // @param offset: the starting offset of the data requested to be written
    // @param length: the length of the data requested to be written
    // @param cloneCtx: clone context
    // @param datastore: datastore pointer
    CSErrorCode flattenWriteInternal(SequenceNum sn,
                            off_t offset,
                            size_t length,
                            const std::unique_ptr<CloneContext>& cloneCtx,
                            CSDataStore* datastore);

    // Snapshot or clone OBJ_SIZE is maybe different from write block size 
    // OBJ_SIZE maybe 64KB, block size maybe 4KB / 512B
    // OBJ_SIZE alreadys bigger than block size
    // MergeParentAndWrite is used for read the parent obj and merge with
    // the write data and write to the chunk file
    // @param sn: the sequence number of the snapshot file to be loaded
    // @param buf: the data requested to be written
    // @param offset: the starting offset of the data requested to be written
    // @param length: the length of the data requested to be written
    // @param cloneCtx: clone context
    // @param datastore: datastore pointer
    CSErrorCode MergeParentAndWrite(SequenceNum sn,
                            const butil::IOBuf& buf,
                            off_t offset,
                            size_t length,
                            const std::unique_ptr<CloneContext>& cloneCtx,
                            CSDataStore* datastore);
    // judge if the offset and length is align with the OBJ_SIZE
    // if true aligned else not aligned
    // @param offset: the starting offset of the data requested to be written
    // @param length: the length of the data requested to be written
    bool isAlignWithObjSize(off_t offset, size_t length);

 private:
    /**
     * Determine whether you need to create a new snapshot
     * @param sn: write request sequence number
     * @return: true means to create a snapshot;
     *          false means no need to create a snapshot
     */
    bool needCreateSnapshot(SequenceNum sn, std::shared_ptr<SnapContext> ctx);
    /**
     * To create a snapshot chunk
     * @param sn: sequence number of the snapshot
     */
    CSErrorCode createSnapshot(SequenceNum sn);
    /**
     * Determine whether to copy on write
     * @param sn: write request sequence number
     * @return: true means cow is required; false means cow is not required
     */
    bool needCow(SequenceNum sn, std::shared_ptr<SnapContext> ctx);
    /**
     * Copy the uncopied data in the specified area from the chunk file
     * to the snapshot file
     * @param offset: the starting offset of the write data area
     * @param length: the length of the write data area
     * @return: return error code
     */
    CSErrorCode copy2Snapshot(off_t offset, size_t length);

 private:
    // The shift of the BlockSize of the UpLevel BlockDevice, for example 9 / 12
    uint32_t blockSize_shift_;
    // Snapshot file pointer
    std::shared_ptr<CSSnapshots> snapshots_;
};

}  // namespace chunkserver
}  // namespace curve

#endif  // SRC_CHUNKSERVER_DATASTORE_CHUNKSERVER_CHUNKFILE_V2_H_
