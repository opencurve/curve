/*
 *  Copyright (c) 2020 NetEase Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

syntax = "proto2";
package curve.chunkserver;

option cc_generic_services = true;
option go_package = "proto/chunk";

// Qos parameters
message QosRequestParas {
    optional uint32 clientId = 1;
    optional int32 dmclockDelta = 2;
    optional int32 dmclockRho = 3;
}

message QosResponseParas {
    optional int32 phase = 1;   // 0: represents the reservation stage; 1: Representing the priority stage
    optional int32 cost = 2;    //
}

// For chunk
enum CHUNK_OP_TYPE {
    CHUNK_OP_DELETE = 0;            // Delete chunk
    CHUNK_OP_READ = 1;              // Read chunk
    CHUNK_OP_WRITE = 2;             // Write chunk
    CHUNK_OP_READ_SNAP = 3;         // read chunk snapshot
    // TODO(wudemiao): later replaced with CHUNK_OP_DELETE_SNAP_OR_CORRECT_SN,
    // Ensure consistency with chunkserver interface
    CHUNK_OP_DELETE_SNAP = 4;       // delete chunk snapshot
    CHUNK_OP_CREATE_CLONE = 5;      // Create clone chunk
    CHUNK_OP_RECOVER = 6;           // Restore clone chunk
    CHUNK_OP_PASTE = 7;             // paste chunk internal request
    CHUNK_OP_UNKNOWN = 8;           // unknown Op
    CHUNK_OP_SCAN = 9;              // scan oprequest
};

// The actual data of read/write is in the attachment of rpc
message ChunkRequest {
    required CHUNK_OP_TYPE opType = 1;  // for all
    required uint32 logicPoolId = 2;    // for all  // logicPoolId is actually uint16, but proto does not have uint16
    required uint32 copysetId = 3;      // for all
    required uint64 chunkId = 4;        // for all
    optional uint64 appliedIndex = 5;   // for read
    optional uint32 offset = 6;         // for read/write
    optional uint32 size = 7;           // for read/write/clone Read data size/Write data size/Create snapshot request represents the chunk size of the request creation
    optional QosRequestParas deltaRho = 8; // for read/write
    optional uint64 sn = 9;             // for write/read snapshot, in the write request, represents the current version number of the file, and in the read snapshot request, represents the version number of the requested chunk
    optional uint64 correctedSn = 10;   // for CreateCloneChunk/DeleteChunkSnapshotOrCorrectedSn used to modify the correctedSn of a chunk
    optional string location = 11;      // for CreateCloneChunk
    optional string cloneFileSource = 12;   // for write/read
    optional uint64 cloneFileOffset = 13;   // for write/read
    optional uint64 sendScanMapTimeoutMs = 14;         // for scan chunk
    optional uint32 sendScanMapRetryTimes= 15;         // for scan chunk
    optional uint64 sendScanMapRetryIntervalUs = 16;   // for scan chunk
    optional bool readMetaPage = 17;                   // for scan chunk
    optional uint64 fileId = 18;  // for io fence
    optional uint64 epoch = 19;  // for io fence
};

enum CHUNK_OP_STATUS {
    CHUNK_OP_STATUS_SUCCESS = 0;            // Success
    CHUNK_OP_STATUS_REDIRECTED = 1;         // Not a leader, redirect
    CHUNK_OP_STATUS_DISK_FAIL = 2;          // Disk returned error
    CHUNK_OP_STATUS_CRC_FAIL = 3;           // CRC verification failed
    CHUNK_OP_STATUS_INVALID_REQUEST = 4;    // The request parameters are incorrect
    CHUNK_OP_STATUS_NOSPACE = 5;            // Insufficient space
    CHUNK_OP_STATUS_COPYSET_NOTEXIST = 6;   // Copyset does not exist
    CHUNK_OP_STATUS_CHUNK_NOTEXIST = 7;     // Chunk or its snapshot file does not exist
    CHUNK_OP_STATUS_FAILURE_UNKNOWN = 8;    // Other errors
    CHUNK_OP_STATUS_OVERLOAD = 9;           // Overload indicates that the server has too many requests that have not been processed and returned
    CHUNK_OP_STATUS_BACKWARD = 10;          // The requested version falls behind the current chunk version
    CHUNK_OP_STATUS_CHUNK_EXIST = 11;       // Chunk already exists
    CHUNK_OP_STATUS_EPOCH_TOO_OLD = 12;     // request epoch too old
};

message ChunkResponse {
    required CHUNK_OP_STATUS status = 1;
    optional string redirect = 2;       // Not the leader, redirect to the leader
    optional uint64 appliedIndex = 3;   // Return the latest committedIndex, note that both read and write must be returned
    optional QosResponseParas phaseCost = 4; // for read/write
    optional uint64 chunkSn = 5;        // for GetChunkInfo represents the version number of the chunk file, while 0 indicates that it does not exist
    optional uint64 snapSn = 6;         // for GetChunkInfo represents the version number of the Chunk file snapshot, while 0 indicates that it does not exist
};

message GetChunkInfoRequest {
    required uint32 logicPoolId = 1;
    required uint32 copysetId = 2;
    required uint64 chunkId = 3;
};

message GetChunkInfoResponse {
    required CHUNK_OP_STATUS status = 1;
    optional string redirect = 2;       // Not the leader, redirect to the leader
    repeated uint64 chunkSn = 3;        // Chunk version number and snapshot version number
};

message GetChunkHashRequest {
    required uint32 logicPoolId = 1;
    required uint32 copysetId   = 2;
    required uint64 chunkId     = 3;
    required uint32 offset      = 4;
    required uint32 length      = 5;
};

message GetChunkHashResponse {
    required CHUNK_OP_STATUS status = 1;
    optional string hash = 2;   // The hash value that can indicate the status of chunk data, usually crc32c
};

message CreateS3CloneChunkRequest {
    required uint32 logicPoolId = 1;
    required uint32 copysetId = 2;
    required uint64 chunkId = 3;
    optional uint64 correctedSn = 4;
    optional string chunkLocationInfo = 5;
};

message CreateS3CloneChunkResponse {
    required CHUNK_OP_STATUS status = 1;
    optional string redirect = 2;       // Not the leader, redirect to the leader
};

message UpdateEpochRequest {
    required uint64 fileId = 1;
    required uint64 epoch = 2;
};

message UpdateEpochResponse {
    required CHUNK_OP_STATUS status = 1;
};

service ChunkService {
    rpc DeleteChunk (ChunkRequest) returns (ChunkResponse);
    rpc ReadChunk (ChunkRequest) returns (ChunkResponse);
    rpc WriteChunk (ChunkRequest) returns (ChunkResponse);

    rpc ReadChunkSnapshot (ChunkRequest) returns (ChunkResponse);
    rpc DeleteChunkSnapshotOrCorrectSn (ChunkRequest) returns (ChunkResponse);

    rpc GetChunkInfo (GetChunkInfoRequest) returns (GetChunkInfoResponse);
    rpc GetChunkHash (GetChunkHashRequest) returns (GetChunkHashResponse);

    rpc CreateCloneChunk (ChunkRequest) returns (ChunkResponse);

    rpc CreateS3CloneChunk(CreateS3CloneChunkRequest) returns(CreateS3CloneChunkResponse);

    rpc RecoverChunk (ChunkRequest) returns (ChunkResponse);

    rpc UpdateEpoch(UpdateEpochRequest) returns (UpdateEpochResponse);
};
