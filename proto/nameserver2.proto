/*
 *  Copyright (c) 2020 NetEase Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

syntax="proto2";
import "proto/common.proto";
package curve.mds;

option cc_generic_services = true;
option go_package = "proto/nameserver2";

// fileinfo
enum FileType {
    INODE_DIRECTORY = 0;
    INODE_PAGEFILE = 1;
    INODE_APPENDFILE = 2;
    INODE_APPENDECFILE = 3;
    INODE_SNAPSHOT_PAGEFILE = 4;
};

enum FileStatus {
    //File creation completed
    kFileCreated = 0;
    //Deleting files
    kFileDeleting = 1;

    //File is being cloned
    kFileCloning = 2;
    //File metadata installation completed
    kFileCloneMetaInstalled = 3;
    //File cloning completed
    kFileCloned = 4;
    //The file is being cloned
    kFileBeingCloned = 5;
}

enum ThrottleType {
    IOPS_TOTAL = 1;
    IOPS_READ = 2;
    IOPS_WRITE = 3;
    BPS_TOTAL = 4;
    BPS_READ = 5;
    BPS_WRITE = 6;
}

message ThrottleParams {
    required ThrottleType type = 1;
    required uint64 limit = 2;
    optional uint64 burst = 3;
    optional uint64 burstLength = 4;
}

message FileThrottleParams {
    repeated ThrottleParams throttleParams = 1;
}

message FileInfo {
    optional    uint64      id = 1;
    optional    string      fileName = 2;
    optional    uint64      parentId = 3;
    optional    FileType    fileType = 4;
    optional    string      owner = 5;
    optional    uint32      chunkSize = 6;
    optional    uint32      segmentSize = 7;
    optional    uint64      length = 8;
    optional    uint64      ctime  = 9;
    optional    uint64      seqNum =  10;
    optional    FileStatus  fileStatus = 11;
    //Used to restore usage in scenarios where files are transferred to the recycle bin,
    //Used in the RecycleBin directory/not used in other scenarios
    optional    string      originalFullPathName = 12;

    //CloneSource is currently used to store clone sources (currently mainly used for curvefs)
    //Later on, we can consider storing s3 related information
    optional    string      cloneSource   =    13;

    //CloneLength The length of the clone source file used for extension during the clone process
    optional    uint64      cloneLength =  14;
    optional    uint64      stripeUnit = 15;
    optional    uint64      stripeCount = 16;

    optional    FileThrottleParams throttleParams = 17;
    optional    uint64      epoch = 18;
    optional    string      poolset = 19;
    optional    uint32      blocksize = 20;
}

// status code
enum  StatusCode {
    //Execution successful
    kOK = 0;

    //File already exists
    kFileExists = 101;
    //File does not exist
    kFileNotExists = 102;
    //Non directory type
    kNotDirectory = 103;
    //Incoming parameter error
    kParaError = 104;
    //Shrinking files, currently not supported
    kShrinkBiggerFile = 105;
    //Expansion unit error, not an integer multiple of segment size
    kExtentUnitError = 106;
    //Segment not allocated
    kSegmentNotAllocated = 107;
    //Segment allocation failed
    kSegmentAllocateError = 108;
    //Directory does not exist
    kDirNotExist = 109;
    //Function not supported
    kNotSupported = 110;
    //Owner authentication failed
    kOwnerAuthFail = 111;
    //Directory is not empty
    kDirNotEmpty = 112;

    //The file is already in a snapshot
    kFileUnderSnapShot = 120;
    //The file is not in the snapshot
    kFileNotUnderSnapShot = 121;
    //Snapshot deletion in progress
    kSnapshotDeleting = 122;
    //The snapshot file does not exist
    kSnapshotFileNotExists = 123;
    //Snapshot file deletion failed
    kSnapshotFileDeleteError = 124;
    //Session does not exist
    kSessionNotExist = 125;
    //The file is already in use
    kFileOccupied = 126;

    kCloneFileNameIllegal = 127;
    kCloneStatusNotMatch = 128;
    //File deletion failed
    kCommonFileDeleteError = 129;
    //File ID mismatch
    kFileIdNotMatch = 130;
    //The file is being deleted
    kFileUnderDeleting = 131;
    //The file length does not meet the requirements
    kFileLengthNotSupported = 132;
    //The file is being cloned
    kDeleteFileBeingCloned = 133;
    //Client version mismatch
    kClientVersionNotMatch = 134;
    //The snapshot function is disabled
    kSnapshotFrozen = 135;
    //The snapshot clone service cannot be connected
    kSnapshotCloneConnectFail = 136;
    //The snapshot clone service is not initialized
    kSnapshotCloneServerNotInit = 137;
    // recover file status is CloneMetaInstalled
    kRecoverFileCloneMetaInstalled = 138;
    // recover file fail
    kRecoverFileError = 139;
    // epoch too old
    kEpochTooOld = 140;
    // poolset doesn't exist
    kPoolsetNotExist = 141;
    //Metadata storage error
    kStorageError = 501;
    //Internal error
    KInternalError = 502;
};

//chunkinfo
message PageFileChunkInfo {
    required uint32 copysetID = 3;
    required uint64 chunkID = 2;
}

message PageFileSegment {
    required uint32 logicalPoolID = 1;
    required uint32 segmentSize = 3;
    required uint32 chunkSize = 4;
    required uint64 startOffset = 2;
    repeated  PageFileChunkInfo chunks = 5;
}

message DiscardSegmentInfo {
    required FileInfo fileInfo = 1;
    required PageFileSegment pageFileSegment = 2;
}

message CreateFileRequest {
    required string     fileName = 1;
    required FileType   fileType = 3;
    optional uint64     fileLength = 4;

    required string     owner = 2;
    optional string     signature = 5;
    required uint64     date = 6;
    optional uint64     stripeUnit = 7;
    optional uint64     stripeCount = 8;
    optional string     poolset = 9;
};

message CreateFileResponse {
    required StatusCode statusCode = 1;
}

message DeleteFileRequest {
    required string     fileName = 1;
    required string     owner = 2;
    optional string     signature = 3;
    required uint64     date = 4;
    optional uint64     fileId = 5;
    optional bool       forceDelete = 6;
};

message DeleteFileResponse {
    required StatusCode statusCode = 1;
}

message RecoverFileRequest {
    required string     fileName = 1;
    required string     owner = 2;
    optional string     signature = 3;
    required uint64     date = 4;
    optional uint64     fileId = 5;
};

message RecoverFileResponse {
    required StatusCode statusCode = 1;
}

message GetFileInfoRequest {
    required string     fileName = 1;

    required string     owner = 2;
    optional string     signature = 3;
    required uint64     date = 4;
}

message GetFileInfoResponse {
    required StatusCode statusCode = 1;
    optional FileInfo fileInfo = 2;
}

message GetOrAllocateSegmentRequest {
    required string     fileName = 1;
    required uint64     offset = 3;
    required bool       allocateIfNotExist = 4;
    optional uint64     seqNum = 5;

    required string     owner = 2;
    optional string     signature = 6;
    required uint64     date = 7;

    optional uint64     epoch = 8;
}

message GetOrAllocateSegmentResponse {
    required StatusCode statusCode = 1;
    optional PageFileSegment pageFileSegment = 2;
}

message DeAllocateSegmentRequest {
    required string fileName = 1;
    required string owner = 2;
    required uint64 offset = 3;
    optional string signature = 4;
    required uint64 date = 5;
}

message DeAllocateSegmentResponse {
    required StatusCode statusCode = 1;
}

message RenameFileRequest {
    required string     oldFileName = 1;
    required string     newFileName = 2;

    required string     owner = 3;
    optional string     signature = 4;
    required uint64     date = 7;


    optional uint64     oldFileID = 5;
    optional uint64     newFileID = 6;
}

message RenameFileResponse {
    required StatusCode statusCode = 1;
}

message ExtendFileRequest {
    required string     fileName = 1;
    required uint64     newSize = 3;

    required string     owner = 2;
    optional string     signature = 4;
    required uint64     date = 5;
}

message ExtendFileResponse {
    required StatusCode statusCode = 1;
}

message ChangeOwnerRequest {
    //Need to change the fileName of the owner's file
    required string fileName = 1;
    //I hope the new owner after the file owner changes
    required string newOwner = 2;
    //The ChangerOwner interface can only be called with root permission, and an owner with root permission needs to be passed in
    required string rootOwner = 3;
    //The signature for verifying the root identity
    required string signature = 4;
    //Used to recalculate the signature on the mds side
    required uint64 date = 5;
}

//Returns the execution result of ChangeOwner, successfully returning statusCode::kOK
//Failure may return kFileNotExists, kOwnerAuthFail, kFileOccupied, kStorageError, etc. The error codes that may be returned will continue to be supplemented in the future
message ChangeOwnerResponse {
    required StatusCode statusCode = 1;
}

message ListDirRequest {
    required string     fileName = 1;
    required string     owner = 2;
    optional string     signature = 3;
    required uint64     date = 4;
}

message ListDirResponse {
    required StatusCode statusCode = 1;
    repeated FileInfo fileInfo = 2;
}

// create snapshot
message CreateSnapShotRequest {
    required string     fileName = 1;

    required string     owner = 2;
    optional string     signature = 3;
    required uint64     date = 4;
}

message CreateSnapShotResponse {
    required StatusCode statusCode = 1;
    optional FileInfo   snapShotFileInfo = 2;
}

// list snapshots
message ListSnapShotFileInfoRequest {
    required string     fileName = 1;
    repeated uint64     seq = 3;

    required string     owner = 2;
    optional string     signature = 4;
    required uint64     date = 5;
}

message ListSnapShotFileInfoResponse {
    required StatusCode statusCode = 1;
    repeated FileInfo fileInfo = 2;
}

// delete snapshot
message DeleteSnapShotRequest {
    required string     fileName = 1;
    required uint64     seq = 3;

    required string     owner = 2;
    optional string     signature = 4;
    required uint64     date = 5;
}

message DeleteSnapShotResponse {
    required StatusCode statusCode = 1;
}

// check snapshot status

message CheckSnapShotStatusRequest {
    required string     fileName = 1;
    required uint64     seq = 3;

    required string     owner = 2;
    optional string     signature = 4;
    required uint64     date = 5;
}

//FileStatus and progress are only assigned values when statusCode is kOK
//Only when fileStatus is kFileDeleting, progress represents the progress of snapshot file deletion, otherwise progress returns 0
message CheckSnapShotStatusResponse {
    required StatusCode statusCode = 1;
    optional FileStatus     fileStatus = 2;
    optional uint32 progress  = 3;
}

// session rpcs
enum SessionStatus {
    kSessionOK = 0;
    kSessionStaled = 1;
    kSessionDeleted = 2;
};

message ProtoSession {
    required string sessionID  = 1;
    required uint32 leaseTime = 2;
    required uint64 createTime = 3;
    required SessionStatus sessionStatus = 4;
    // other useful infos
};

message CloneSourceSegment {
    required uint64 segmentSize = 1;
    repeated uint64 allocatedSegmentOffset = 2;
}

message OpenFileRequest {
    required string fileName = 1;
    required string owner = 2;
    optional string signature = 3;
    required uint64 date = 4;
    optional string clientVersion = 5;
};

//The return value of statusCode is detailed in the definition of StatusCode:
// StatusCode::kOK
// StatusCode::kFileNotExists
// StatusCode::kStorageError
// StatusCode::kFileOccupied
// StatusCode::KInternalError
message OpenFileResponse {
    required StatusCode statusCode = 1;
    optional ProtoSession protoSession = 2;
    optional FileInfo   fileInfo = 3;
    optional CloneSourceSegment cloneSourceSegment = 4;
};

message CloseFileRequest {
    required string     fileName = 1;
    required string     sessionID = 2;

    required string     owner = 3;
    optional string     signature = 4;
    required uint64     date = 5;

    optional string     clientIP = 6;
    optional uint32     clientPort = 7;
};

//The return value of statusCode is detailed in the definition of StatusCode:
// StatusCode::kOK
// StatusCode::kFileNotExists
// StatusCode::kStorageError
// StatusCode::kSessionNotExist
// StatusCode::KInternalError
message CloseFileResponse {
    required StatusCode statusCode = 1;
}

message ReFreshSessionRequest {
    required string     fileName = 1;
    required string     sessionID = 2;

    required string     owner = 3;
    required uint64     date = 4; //current time
    optional string     signature = 5;
    optional string     clientVersion = 6;
    optional string     clientIP = 7;
    optional uint32     clientPort = 8;
}

//The return value of statusCode is detailed in the definition of StatusCode:
// StatusCode::kOK
// StatusCode::kFileNotExists
// StatusCode::kStorageError
// StatusCode::kSessionNotExist
message ReFreshSessionResponse {
    required StatusCode statusCode = 1;
    required string     sessionID = 2;
    optional FileInfo   fileInfo = 3;
    optional ProtoSession protoSession = 4;
};


message  CreateCloneFileRequest {
    required string     fileName = 1;
    required FileType   fileType = 2;
    required uint64     fileLength = 3;
    required uint64     seq = 4;
    required uint32     chunksize = 5;
    required string     owner = 6;
    optional string     signature = 7;
    required uint64     date =8;
    required string     cloneSource = 9;
    optional uint64     stripeUnit = 10;
    optional uint64     stripeCount = 11;
    optional string     poolset = 12;
}

message CreateCloneFileResponse {
    required StatusCode statusCode = 1;
    optional FileInfo fileInfo = 2;
}

message SetCloneFileStatusRequest {
    required string     fileName = 1;
    optional uint64     fileID = 2;
    required FileStatus fileStatus = 3;

    required string     owner = 4;
    optional string     signature = 5;
    required uint64     date = 6;
}

message SetCloneFileStatusResponse {
    required StatusCode statusCode = 1;
}

message GetAllocatedSizeRequest {
    required string fileName = 1;
}

message GetAllocatedSizeResponse {
    required StatusCode statusCode = 1;
    //Allocation size of files or directories
    optional uint64 allocatedSize = 2;
    //Key is the logical pool id, and value is the allocation size
    map<uint32, uint64> allocSizeMap = 3;
}

message GetFileSizeRequest {
    required string fileName = 1;
}

message GetFileSizeResponse {
    required StatusCode statusCode = 1;
    //The file length of a file or directory
    optional uint64 fileSize = 2;
}

message ClientInfo {
    required string ip = 1;
    required uint32 port = 2;
}

message ListClientRequest {
    optional bool listAllClient = 1;
}

message ListClientResponse {
    required StatusCode statusCode = 1;
    repeated ClientInfo clientInfos = 2;
}

message FindFileMountPointRequest {
    required string fileName = 1;
}

message FindFileMountPointResponse {
    required StatusCode statusCode = 1;
    repeated ClientInfo clientInfo = 2;
}

message ListVolumesOnCopysetsRequest {
    repeated common.CopysetInfo copysets = 1;
}

message ListVolumesOnCopysetsResponse {
    required StatusCode statusCode = 1;
    repeated string fileNames = 2;
}

message UpdateFileThrottleParamsRequest {
    required string fileName = 1;
    required string owner = 2;
    optional string signature = 3;
    required uint64 date = 4;
    required ThrottleParams throttleParams = 5;
}

message UpdateFileThrottleParamsResponse {
    required StatusCode statusCode = 1;
}

message IncreaseFileEpochRequest {
    required string     fileName = 1;

    required string     owner = 2;
    optional string     signature = 3;
    required uint64     date = 4;
}

message IncreaseFileEpochResponse {
    required StatusCode statusCode = 1;
    optional FileInfo fileInfo = 2;
    repeated common.ChunkServerLocation csLocs = 3;
}

service CurveFSService {
    // basic rpcs
    rpc     CreateFile(CreateFileRequest) returns (CreateFileResponse);
    rpc     DeleteFile(DeleteFileRequest) returns (DeleteFileResponse);
    rpc     RecoverFile(RecoverFileRequest) returns (RecoverFileResponse);
    rpc     GetFileInfo(GetFileInfoRequest) returns (GetFileInfoResponse);
    rpc     GetOrAllocateSegment(GetOrAllocateSegmentRequest)
                returns (GetOrAllocateSegmentResponse);
    rpc     DeAllocateSegment(DeAllocateSegmentRequest) returns (DeAllocateSegmentResponse);
    rpc     RenameFile(RenameFileRequest) returns (RenameFileResponse);
    rpc     ExtendFile(ExtendFileRequest) returns (ExtendFileResponse);
    rpc     ChangeOwner(ChangeOwnerRequest) returns (ChangeOwnerResponse);
    rpc     ListDir(ListDirRequest) returns (ListDirResponse);
    rpc     IncreaseFileEpoch(IncreaseFileEpochRequest) returns (IncreaseFileEpochResponse);

    // snapshot rpcs
    rpc     CreateSnapShot(CreateSnapShotRequest)
                returns (CreateSnapShotResponse);
    rpc     ListSnapShot(ListSnapShotFileInfoRequest)
            returns (ListSnapShotFileInfoResponse);
    rpc     DeleteSnapShot(DeleteSnapShotRequest)
            returns (DeleteSnapShotResponse);
    rpc     CheckSnapShotStatus(CheckSnapShotStatusRequest)
            returns (CheckSnapShotStatusResponse);
    rpc     GetSnapShotFileSegment(GetOrAllocateSegmentRequest)
                returns (GetOrAllocateSegmentResponse);

    // session rpcs
    rpc     OpenFile(OpenFileRequest) returns (OpenFileResponse);
    rpc     CloseFile(CloseFileRequest) returns (CloseFileResponse);
    rpc     RefreshSession(ReFreshSessionRequest)
        returns (ReFreshSessionResponse);

    // clone rpcs
    rpc     CreateCloneFile(CreateCloneFileRequest) returns (CreateCloneFileResponse);
    rpc     SetCloneFileStatus(SetCloneFileStatusRequest) returns (SetCloneFileStatusResponse);

    // curve status
    rpc     GetAllocatedSize(GetAllocatedSizeRequest) returns (GetAllocatedSizeResponse);
    rpc     GetFileSize(GetFileSizeRequest) returns (GetFileSizeResponse);
    rpc     ListClient(ListClientRequest) returns (ListClientResponse);
    rpc     FindFileMountPoint(FindFileMountPointRequest) returns (FindFileMountPointResponse);
    rpc     ListVolumesOnCopysets(ListVolumesOnCopysetsRequest) returns (ListVolumesOnCopysetsResponse);
    rpc     UpdateFileThrottleParams(UpdateFileThrottleParamsRequest) returns (UpdateFileThrottleParamsResponse);
}
