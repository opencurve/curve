/*
 *  Copyright (c) 2021 NetEase Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

syntax="proto2";
package curvefs.metaserver;
option cc_generic_services = true;

enum MetaStatusCode {
    OK = 0;
    UNKNOWN_ERROR = 1;
    PARAM_ERROR = 2;
    NOT_FOUND = 3;
    INODE_EXIST = 4;
    DENTRY_EXIST = 5;
    SYM_LINK_EMPTY = 6;
    RPC_ERROR = 7;
    TARGET_DIRECTORY_EXIST = 8;
    HANDLE_PENDING_TX_FAILED = 9;
    HANDLE_TX_FAILED = 10;
}

// dentry interface
message GetDentryRequest {
    required uint32 fsId = 1;
    required uint64 parentInodeId = 2;
    required string name = 3;
    required uint64 txId = 4;
}

enum DentryFlag {
    TYPE_FILE_FLAG = 1;
    DELETE_MARK_FLAG = 2;
}

message Dentry {
    required uint32 fsId = 1;
    required uint64 inodeId = 2;
    required uint64 parentInodeId = 3;
    required string name = 4;
    required uint64 txId = 5;
    optional uint32 flag = 6;
}

message GetDentryResponse {
    required MetaStatusCode statusCode = 1;
    optional Dentry dentry = 2;
}

message ListDentryRequest {
    required uint32 fsId = 1;
    required uint64 dirInodeId = 2;
    required uint64 txId = 3;
    optional string last = 4;  // the name of last dentry
    optional uint32 count = 5;  // the number of dentry required
}

message ListDentryResponse {
    required MetaStatusCode statusCode = 1;
    repeated Dentry dentrys = 2;
}

message CreateDentryRequest {
    required Dentry dentry = 1;
}

message CreateDentryResponse {
    required MetaStatusCode statusCode = 1;
}

message DeleteDentryRequest {
    required uint32 fsId = 1;
    required uint64 parentInodeId = 2;
    required string name = 3;
    required uint64 txId = 4;
}

message DeleteDentryResponse {
    required MetaStatusCode statusCode = 1;
}

message PrepareRenameTxRequest {
    repeated Dentry dentrys = 1;
}

message PrepareRenameTxResponse {
    required MetaStatusCode statusCode = 1;
}

// inode interface
message GetInodeRequest {
    required uint32 fsId = 1;
    required uint64 inodeId = 2;
}

enum FsFileType {
    TYPE_DIRECTORY = 1;
    TYPE_FILE = 2;
    TYPE_SYM_LINK = 3;
    TYPE_S3 = 4;
};

message VolumeExtent {
    required uint64 fsOffset = 1;
    required uint64 volumeOffset = 2;
    required uint64 length = 3;
    required bool isused = 4;
}

message VolumeExtentList {
    repeated VolumeExtent volumeExtents = 1;
}


message S3ChunkInfo {
    required uint64 chunkId = 1;
    required uint64 version = 2;
    required uint64 offset = 3;
    required uint64 len = 4;  // file logic length
    required uint64 size = 5; // file size in object storage
};

message S3ChunkInfoList {
    repeated S3ChunkInfo s3Chunks = 1;
};

// Todo: time unit of atime/ctime/mtime need fix
message Inode {
    required uint64 inodeId = 1;
    required uint32 fsId = 2;
    required uint64 length = 3;
    required uint32 ctime = 4;
    required uint32 mtime = 5;
    required uint32 atime = 6;
    required uint32 uid = 7;
    required uint32 gid = 8;
    required uint32 mode = 9;
    required uint32 nlink = 10;
    required FsFileType type = 11;
    optional string symlink = 12;   // TYPE_SYM_LINK only
    optional VolumeExtentList volumeExtentList = 13;  // TYPE_FILE only
    optional S3ChunkInfoList s3ChunkInfoList = 14; // TYPE_S3 only
    optional uint64 version = 15;
}

message GetInodeResponse {
    required MetaStatusCode statusCode = 1;
    optional Inode inode = 2;
}

message CreateInodeRequest {
    required uint32 fsId = 1;
    required uint64 length = 2;
    required uint32 uid = 3;
    required uint32 gid = 4;
    required uint32 mode = 5;
    required FsFileType type = 6;
    optional string symlink = 7;   // TYPE_SYM_LINK only
}

message CreateInodeResponse {
    required MetaStatusCode statusCode = 1;
    optional Inode inode = 2;
}

message CreateRootInodeRequest {
    required uint32 fsId = 1;
    required uint32 uid = 2;
    required uint32 gid = 3;
    required uint32 mode = 4;
}

message CreateRootInodeResponse {
    required MetaStatusCode statusCode = 1;
}

message UpdateInodeRequest {
    required uint64 inodeId = 1;
    required uint32 fsId = 2;
    optional uint64 length = 3;
    optional uint32 ctime = 4;
    optional uint32 mtime = 5;
    optional uint32 atime = 6;
    optional uint32 uid = 7;
    optional uint32 gid = 8;
    optional uint32 mode = 9;
    optional VolumeExtentList volumeExtentList = 10;  // TYPE_FILE only
    optional S3ChunkInfoList s3ChunkInfoList = 11; // TYPE_S3 only
}

message UpdateInodeResponse {
    required MetaStatusCode statusCode = 1;
}
message DeleteInodeRequest {
    required uint32 fsId = 1;
    required uint64 inodeId = 2;
}

message DeleteInodeResponse {
    required MetaStatusCode statusCode = 1;
}

message UpdateInodeS3VersionRequest {
    required uint64 inodeId = 1;
    required uint32 fsId = 2;
}

message UpdateInodeS3VersionResponse {
    required MetaStatusCode statusCode = 1;
    optional uint64 version = 2;
}

service MetaServerService {
    // dentry interface
    rpc GetDentry(GetDentryRequest) returns (GetDentryResponse);
    rpc ListDentry(ListDentryRequest) returns (ListDentryResponse);
    rpc CreateDentry(CreateDentryRequest) returns (CreateDentryResponse);
    rpc DeleteDentry(DeleteDentryRequest) returns (DeleteDentryResponse);
    rpc PrepareRenameTx(PrepareRenameTxRequest) returns (PrepareRenameTxResponse);

    // inode interface
    rpc GetInode(GetInodeRequest) returns (GetInodeResponse);
    rpc CreateInode(CreateInodeRequest) returns (CreateInodeResponse);
    rpc UpdateInode(UpdateInodeRequest) returns (UpdateInodeResponse);
    rpc DeleteInode(DeleteInodeRequest) returns (DeleteInodeResponse);
    rpc CreateRootInode(CreateRootInodeRequest) returns
                                            (CreateRootInodeResponse);
    rpc UpdateInodeS3Version(UpdateInodeS3VersionRequest) returns
                                        (UpdateInodeS3VersionResponse);
}

